package integration

import (
	"bufio"
	"fmt"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"strconv"
	"strings"
	"testing"

	"github.com/magefile/mage/sh"
)

func TestIntegration(t *testing.T) {
	projectName := strings.ToLower(t.Name())
	outputDir := t.TempDir()
	composeFile := "./test-run-exec/docker-compose.yml"

	localExecFilename := "my-local-job.txt"
	execFilename := "my-exec-job.txt"
	runFilename := "my-run-job.txt"

	sleepForSec := 10
	scheduleEverySec := 3
	expectedExecutions := (sleepForSec / scheduleEverySec)

	if _, err := os.Stat(composeFile); os.IsNotExist(err) {
		t.Fatalf("Compose file %s not found", composeFile)
	}

	t.Setenv("COMPOSE_FILE", composeFile)
	t.Setenv("COMPOSE_PROJECT_NAME", projectName)
	t.Setenv("OUTPUT_DIR", outputDir)
	t.Setenv("SCHEDULE", fmt.Sprintf("@every %ds", scheduleEverySec))
	t.Setenv("SLEEP_FOR", strconv.Itoa(sleepForSec))
	t.Setenv("LOCAL_EXEC_OUTPUT_FILE", localExecFilename)
	t.Setenv("EXEC_OUTPUT_FILE", execFilename)
	t.Setenv("RUN_OUTPUT_FILE", runFilename)

	for _, command := range []string{"config", "build", "pull"} {
		t.Run("docker compose "+command, func(t *testing.T) {
			t.Logf("Running docker compose %s", command)
			if err := sh.RunV("docker", "compose", command); err != nil {
				t.Fatal(err)
			}
		})
	}

	t.Run("docker compose up", func(t *testing.T) {
		if err := sh.RunV("docker", "compose", "up", "--exit-code-from", "sleep1"); err != nil {
			t.Fatal(err)
		}

		for _, file := range []string{localExecFilename, execFilename, runFilename} {
			t.Log("Checking for outputs in", file)
			count, content, err := checkFile(filepath.Join(outputDir, file))
			if err != nil {
				t.Error(err)
				continue
			}

			if count != expectedExecutions {
				t.Errorf("expected %d lines in %s, but got %d. File content:\n%s", expectedExecutions, file, count, content)
			}

			// check files generated by the `save-folder` setting
			resultFiles, err := checkSavedResults(file, outputDir)
			if err != nil {
				t.Error(err)
			}

			if len(resultFiles) != 3 {
				keys := slices.Sorted(maps.Keys(resultFiles))
				t.Errorf("expected 3 result files for %s, but got %d. Result files: %v", file, len(resultFiles), keys)
			}

			for file, count := range resultFiles {
				if count != expectedExecutions {
					t.Errorf("expected %d job execution files for %s, but got %d", expectedExecutions, file, count)
				}
			}
		}
	})
}

func checkSavedResults(fileName string, dir string) (map[string]int, error) {
	jobName := strings.TrimSuffix(fileName, filepath.Ext(fileName))
	files, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	// Look in the outpot directory and count the number of files (without the filename prefix)
	// Ofelia produces job executon results with the following naming convention:
	// - 20250419_182443_my-local-job.json
	// - 20250419_182443_my-local-job.stderr.log
	// - 20250419_182443_my-local-job.stdout.log
	//
	// Before counting, we will trim timestamp prefix.

	counts := make(map[string]int)
	for _, file := range files {
		if strings.Contains(file.Name(), jobName) {
			nameSplit := strings.Split(file.Name(), jobName)
			fileType := strings.TrimPrefix(file.Name(), nameSplit[0])
			counts[fileType]++
		}
	}

	// remove original file from counts
	delete(counts, fileName)

	return counts, nil
}

func checkFile(path string) (int, string, error) {
	f, err := os.Open(path)
	if err != nil {
		return 0, "", err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	content := strings.Builder{}
	count := 0
	for scanner.Scan() {
		content.Write(scanner.Bytes())
		content.WriteByte('\n')
		count++
	}

	if err := scanner.Err(); err != nil {
		return 0, "", err
	}

	return count, content.String(), nil
}
